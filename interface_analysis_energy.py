#Analysis of the DNA-Protein interface from data generated by nucplot and curves program
from natsort import natsorted, ns
#import mdtraj as md
import multiprocessing as mp
import pandas as pd
import numpy as np
import io, os, sys, time, tarfile
import zipfile
 
class InMemoryZip(object):
 
	def __init__(self):
		# Create the in-memory file-like object
		self.in_memory_zip = io.BytesIO()
 
	def appendFile(self, file_path, file_name=None):
		if file_name is None:
			p, fn = os.path.split(file_path)
		else:
			fn = file_name
 
		c = open(file_path, "rb").read()
		self.append(fn, c)
 
		return self
 
	def append(self, filename_in_zip, file_contents):
		"""Appends a file with name filename_in_zip and contents of
			file_contents to the in-memory zip."""
 
		# Get a handle to the in-memory zip in append mode
		zf = zipfile.ZipFile(self.in_memory_zip, "a", zipfile.ZIP_DEFLATED, False)
 
		# Write the file to the in-memory zip
		zf.writestr(filename_in_zip, file_contents)
 
		# Mark the files as having been created on Windows so that
		# Unix permissions are not inferred as 0000
		for zfile in zf.filelist:
			zfile.create_system = 0
		
		return self
 
 
	def read(self):
		"""Returns a string with the contents of the in-memory zip."""
		self.in_memory_zip.seek(0)
 		
		return self.in_memory_zip.read()
 
	def writetofile(self, filename):
		"""Writes the in-memory zip to a file."""
 
		f = open(filename, "wb")
		f.write(self.read())
		f.close()
 


def CURVES_CAL(frame_idx):
	print(frame_idx)
	cmd='cp ~/.bin/curves+/cur.inp1 cur_'+str(frame_idx)+'.inp; sed -i \"s/traj_0.pdb/frame_' + str(frame_idx) + '.pdb/g\" \"cur_' + str(frame_idx) +'.inp\" ; sed -i \"s/traj_out/curves_out_' + str(frame_idx) + '/g\" \"cur_' + str(frame_idx) +'.inp\" ; Cur+ < cur_' + str(frame_idx) + '.inp; '
	tarx='tar -uvf Curves.tar curves_out_' + str(frame_idx) + '.lis'
	os.system(cmd)
	cmd='rm  curves_out_'+str(frame_idx)+'_*.pdb curves_out_'+str(frame_idx)+'.cda cur_'+str(frame_idx)+'.inp'
	os.system(cmd)

def NUCPLOT_CAL(frame_idx):
	print(frame_idx)
	frame=traj[frame_idx]
	frame.save_pdb("frame_"+str(frame_idx)+".pdb")
	cmd= "~/software/nucplot_ias/nucplot.scr1 frame_"+str(frame_idx)+".pdb"
	tarx=" tar -uvf Bonds.tar frame_" + str(frame_idx) + ".bond "
	os.system(cmd)
	CURVES_CAL(frame_idx)
	os.system("rm frame_"+str(frame_idx)+".hb2 "+ "frame_"+str(frame_idx)+".nb2 " + "frame_"+str(frame_idx)+".pdb " + "frame_"+str(frame_idx)+".pdb.hbplus.rc " + "frame_"+str(frame_idx)+".pdb.hbadd.bonds")



def NUCPLOT_EXTRACT(chunk):
	#initialize the dataframe
	percent=0
	loopTime=time.time()
	nucdata=pd.DataFrame(columns=["Frame", "P_resname", "P_chain", "P_resid", "P_atom", "PA_charge", "D_resname", "D_chain", "D_resid", "D_atom", "DA_charge", "Dist", "Evdw", "Ecoul", "Enonb", "Type"])
	for file_idx in chunk:
		percent=percent+1
		if(int(float(percent/len(chunk))*100)%10==0):
			print("%.1f" % float(percent/len(chunk)), " LoopTime:", int(time.time()-loopTime))
			loopTime=time.time()
		iidx=0
		frame=int(file_idx.split('.')[0].split('_')[1])
		file_name=tarnucplot.extractfile(file_idx)
		Hbond=False
		Nbond=False
		for line in file_name.readlines():
			sline=line.decode('ASCII')
			if sline.find("HIS") >= 0:
				print("FOUND HIS IN:", file_idx)
				sline=sline.replace("HIS", "HIE")
				print(sline)
			slist=sline.split()
			slength=len(slist)
			if (Hbond == True)  and  (slength > 0) :
				if (slength == 9) and (slist[0] != 'ACE') and (slist[0]!= 'NME') and (slist[0] != 'Pt') and (slist[0]!='AME') and (slist[0]!='AMF') and (slist[4] != 'ACE') and (slist[4]!= 'NME') and (slist[4] != 'Pt') and (slist[4]!='AME') and (slist[4]!='AMF'):
					#print('HBOND:', sline)
					#extract Hbonds
					if slist[1] != "B":
						slist[0:4],slist[4:8]=slist[4:8],slist[0:4]
						#print(slist)
					Patag, Datag = str(slist[0]+"_"+slist[3]), str(slist[4]+"_"+slist[7])
					eps_pd=4.0*float(Matrix_eps.loc[atom_pars.loc[Patag, 'Atype'], atom_pars.loc[Datag, 'Atype']])
					sig_pd=float(Matrix_sig.loc[atom_pars.loc[Patag, 'Atype'], atom_pars.loc[Datag, 'Atype']])
					distij=float(slist[8])*0.1 # from A to nm
					sig_dist=sig_pd/distij
					sig_dist3=sig_dist*sig_dist*sig_dist
					sig_dist6=sig_dist3*sig_dist3
					sig_dist12=sig_dist6*sig_dist6
					Pachr=float(atom_pars.loc[Patag]['Charge'])
					Dachr=float(atom_pars.loc[Datag]['Charge'])
					const_col=138.935485 # from gromacs manual 2016 p.67 :138.935485
					const_e_r=1.0
					ecoul=const_col*Pachr*Dachr/distij/const_e_r
					evdw=eps_pd*(sig_dist12 - sig_dist6)
					enonb=ecoul+evdw
					nucdata.loc[str(frame)+"_"+str(iidx)]={"Frame": frame,
						"P_resname": slist[0], "P_chain": slist[1], "P_resid": slist[2], "P_atom":slist[3], "PA_charge": Pachr,
						"D_resname": slist[4], "D_chain": slist[5], "D_resid": slist[6], "D_atom":slist[7], "DA_charge": Dachr, 
						"Dist":distij, "Evdw": evdw, "Ecoul": ecoul, "Enonb": enonb, "Type": "HB"}
					iidx=iidx+1
				if slist[0] == "protein" :
					#print("HBOND END, NBOND START")
					Nbond=True
					Hbond=False
			else:
				#print("finding:", slength)
				if slength > 0:
					if slist[0] == "Donor" :
						#print("found Hbond")
						Hbond=True
			if (Nbond == True) and (slength > 0) :
				if (slength == 9) and (slist[0] != 'ACE') and (slist[0]!= 'NME') and (slist[0] != 'Pt') and (slist[0]!='AME') and (slist[0]!='AMF') and (slist[4] != 'ACE') and (slist[4]!= 'NME') and (slist[4] != 'Pt') and (slist[4]!='AME') and (slist[4]!='AMF'):
					#extract NBOND
					#print('NBOND:', sline)
					bt="NB"
					Patag, Datag = str(slist[0]+"_"+slist[3]), str(slist[4]+"_"+slist[7])
					eps_pd=4.0*(Matrix_eps.loc[atom_pars.loc[Patag, 'Atype'], atom_pars.loc[Datag, 'Atype']])
					sig_pd=float(Matrix_sig.loc[atom_pars.loc[Patag, 'Atype'], atom_pars.loc[Datag, 'Atype']])
					distij=float(slist[8])*0.1 # from A to nm
					sig_dist=sig_pd/distij
					sig_dist3=sig_dist*sig_dist*sig_dist
					sig_dist6=sig_dist3*sig_dist3
					sig_dist12=sig_dist6*sig_dist6
					Pachr=float(atom_pars.loc[Patag]['Charge'])
					Dachr=float(atom_pars.loc[Datag]['Charge'])
					const_col=1.7366935625 # gromacs manual p.83
					ecoul=const_col*Pachr*Dachr/distij
					evdw=eps_pd*(sig_dist12 - sig_dist6)
					enonb=ecoul+evdw
					nucdata.loc[str(frame)+"_"+str(iidx)]={"Frame": frame,
						"P_resname": slist[0], "P_chain": slist[1], "P_resid": slist[2], "P_atom":slist[3], "PA_charge": Pachr,
						"D_resname": slist[4], "D_chain": slist[5], "D_resid": slist[6], "D_atom":slist[7], "DA_charge": Dachr,
						"Dist":distij, "Evdw": evdw, "Ecoul": ecoul, "Enonb": enonb, "Type": "NB"}

					iidx=iidx+1
	
				if slist[0] == "****" :
					#print("NBOND END")
					Nbond=False
					break
	outid=os.getpid()
	with open('.iNucplot_data_'+str(outid), 'a') as outf:
		nucdata.to_csv(outf, header=False)
	return outid

def CURVES_EXTRACT(chunk):
    
    startA=30
    endA=41
    startB=49
    endB=60
    startC=66
    endC=76
    startD1=84
    endD1=95
    startD2=99
    endD2=110
    startE=116
    endE=136
    
    curdataA=pd.DataFrame(columns=['Frame', 'Level', 'Xdisp',   'Ydisp',   'Inclin',  'Tip', 'Ax-bend'])

    curdataB=pd.DataFrame(columns=['Frame', 'Level', 'Shear',  'Stretch', 'Stagger',  'Buckle',  'Propel', 'Opening'])

    curdataC=pd.DataFrame(columns=['Frame', 'Level', 'Shift',  'Slide', 'Rise',  'Tilt',  'Roll', 'Twist', 'H-Ris', 'H-Twi'])

    curdataD1=pd.DataFrame(columns=['Frame', 'Level','Alpha1','Beta1','Gamma1','Delta1','Epsil1','Zeta1','Chi1','Phase1','Ampli1'])

    curdataD2=pd.DataFrame(columns=['Frame', 'Level','Alpha2','Beta2','Gamma2','Delta2','Epsil2','Zeta2','Chi2','Phase2','Ampli2'])

    curdataE=pd.DataFrame(columns=['Frame', 'Level', 'W12', 'D12', 'W21', 'D21'])
    percent=0
    loopTime=time.time()
    for file_idx in chunk:
        percent=percent+1
        if(int(float(percent/len(chunk))*100)%10==0):
               print("%.1f" % float(percent/len(chunk)), " LoopTime:", int(time.time()-loopTime))
               loopTime=time.time()
        frame=int(file_idx.split('.')[0].split('_')[2])
        file_name=tarcurves.extractfile(file_idx)
        #print(frame)
        i=0
        for line in file_name.readlines():
            #print(i, line.decode('ASCII'))
        
            # extract section A
            if i>=startA and i<=endA :
                sline=line.decode('ASCII')
                curdataA.loc["S_"+str(frame*(endA-startA+1)+i-startA)] = {'Frame':frame, 'Level':i-startA+1,'Xdisp': sline.split()[4], 
                                                            'Ydisp':sline.split()[5] ,'Inclin':sline.split()[6],
                                                            'Tip':sline.split()[7] ,'Ax-bend':sline.split()[8]}
            # extract section B
            if i>=startB and i<=endB :
                sline=line.decode('ASCII')
                curdataB.loc["S_"+str(frame*(endB-startB+1)+i-startB)] = {'Frame':frame, 'Level':i-startB+1,'Shear': sline.split()[4], 
                                                            'Stretch':sline.split()[5] ,'Stagger':sline.split()[6],
                                                            'Buckle':sline.split()[7] ,'Propel':sline.split()[8] ,
                                                            'Opening':sline.split()[9]}
        
            # extract section C
            if i>=startC and i<=endC :
                sline=line.decode('ASCII')
                curdataC.loc["S_"+str(frame*(endC-startC+1)+i-startC)] = {'Frame':frame, 'Level':i-startC+1,'Shift': sline.split()[4], 
                                                            'Slide':sline.split()[5], 'Rise':sline.split()[6], 'Tilt':sline.split()[7],
                                                            'Roll':sline.split()[8], 'Twist':sline.split()[9] ,'H-Ris':sline.split()[10],
                                                            'H-Twi':sline.split()[11]}

            # extract section D1
            if i>=startD1 and i<=endD1 :
                sline=line.decode('ASCII')
                curdataD1.loc["S_"+str(frame*(endD1-startD1+1)+i-startD1)] = {'Frame':frame, 'Level':i-startD1+1,'Alpha1': sline.split()[3], 
                                                                'Beta1':sline.split()[4] ,'Gamma1':sline.split()[5],
                                                                'Delta1':sline.split()[6] ,'Epsil1':sline.split()[7],
                                                                'Zeta1':sline.split()[8] ,'Chi1':sline.split()[9],
                                                                'Phase1':sline.split()[10],'Ampli1':sline.split()[11]}
            # extract section D2
            if i>=startD2 and i<=endD2 :
                sline=line.decode('ASCII')
                curdataD2.loc["S_"+str(frame*(endD2-startD2+1)+i-startD2)] = {'Frame':frame, 'Level':i-startD2+1,'Alpha2': sline.split()[3], 
                                                            'Beta2':sline.split()[4] ,'Gamma2':sline.split()[5],
                                                            'Delta2':sline.split()[6] ,'Epsil2':sline.split()[7],
                                                            'Zeta2':sline.split()[8] ,'Chi2':sline.split()[9],
                                                            'Phase2':sline.split()[10],'Ampli2':sline.split()[11]}

            # extract section E
            if i>=startE and i<=endE :
                sline=line.decode('ASCII')
                tmp=['Nan','Nan','Nan','Nan']
                if ((i-startE) % 2)== 0:
                    if len(sline.split()) > 1:
                        for xx in range(len(sline.split())-1):
                            tmp[xx] = sline.split()[xx+1]
                else:
                    if len(sline.split()) > 3:
                        for xx in range(len(sline.split())-3):
                            tmp[xx] = sline.split()[xx+3]
                               
                curdataE.loc["S_"+str(frame*(endE-startE+1)+i-startE)] = {'Frame':frame, 'Level':sline.split()[0],'W12': tmp[0], 
                                                            'D12':tmp[1] , 'W21':tmp[2], 'D21':tmp[3]}            

            i=i+1

    # combine A to D sections
    curdataA2D=curdataA
    for xx in ['Shear' , 'Stretch', 'Stagger',  'Buckle',  'Propel', 'Opening']:
        curdataA2D[xx]=curdataB[xx]
    for xx in ['Shift',  'Slide', 'Rise',  'Tilt',  'Roll', 'Twist', 'H-Ris', 'H-Twi']:
        curdataA2D[xx]=curdataC[xx]
    for xx in ['Alpha1','Beta1','Gamma1','Delta1','Epsil1','Zeta1','Chi1','Phase1','Ampli1']:
        curdataA2D[xx]=curdataD1[xx]     
    for xx in ['Alpha2','Beta2','Gamma2','Delta2','Epsil2','Zeta2','Chi2','Phase2','Ampli2']:
        curdataA2D[xx]=curdataD2[xx]     

    #Synchronization of write to file between processes
    outid=os.getpid()
    with open(".iCurves_dataA2D_"+str(outid), 'a') as outfa2d:
         curdataA2D.to_csv(outfa2d, header=False)
    with open(".iCurves_dataE_"+str(outid), 'a') as outfe:
         curdataE.to_csv(outfe, header=False)

    return outid
    
def ATOM_PAR(topfile):
	para=pd.DataFrame(columns=["Charge", "Mass"])
	CHOSE=False
	IDX=0
	i=0
	with open(topfile) as lines:
		for line in lines:
			sline=line.split()
			slength=len(sline)
			if slength > 1:
				#print(i, sline)
				if (IDX < 2) and (sline[1] == "moleculetype") :
					CHOSE=True
					IDX=IDX+1
					#print("FIND SECTION")
				else:
					if (slength == 11) and (CHOSE == True) and (sline[3] != 'NME') and (sline[3] != 'ACE') and (sline[3] != 'Pt' and (sline[3] != 'AME') and (sline[3] != 'AMF')):
						para.loc[str(sline[3]+"_"+sline[4])]={"Charge": sline[6], "Mass":sline[7]}
						i=i+1
						#print("READ SECTION")
					if sline[1] == "bonds":
						CHOSE=False
						#print("READ END")
	
	return para
			
	
def ATOM_PAR_LJ(topfile):
        para=pd.DataFrame(columns=["Charge", "Mass", "Atype"])
        paralj=pd.DataFrame(columns=["sigma", "epsilon"])
        CHOSE=False
        CHOSELJ=False
        IDX=0
        i=0
        IDXLJ=0
        j=0
        with open(topfile) as lines:
                for line in lines:
                        sline=line.split()
                        slength=len(sline)
                        if slength > 1:
                                # Get parameters for Atom charges
                                #print(i, sline)
                                if (IDX < 2) and (sline[1] == "moleculetype") :
                                        CHOSE=True
                                        IDX=IDX+1
                                        #print("FIND SECTION")
                                else:
                                        if (slength == 11) and (CHOSE == True) and (sline[3] != 'NME') and (sline[3] != 'ACE') and (sline[3] != 'Pt' and (sline[3] != 'AME') and (sline[3] != 'AMF')):
                                                para.loc[str(sline[3]+"_"+sline[4])]={"Charge": sline[6], "Mass":sline[7], "Atype":sline[1]}
                                                i=i+1
                                                #print("READ SECTION")
                                        if sline[1] == "bonds":
                                                CHOSE=False
                                                #print("READ END")
                                #############################################
                                # Get parameters for L-J factors
                                if( IDXLJ < 2) and (sline[1] == "atomtypes"):
                                        CHOSELJ=True
                                        IDXLJ=IDXLJ+1
                                        #print("FIND SECTION LJ")
                                else:
                                        if (slength == 9) and (CHOSELJ == True) and (sline[4] == "A" and (sline[7] == ";")) :
                                                paralj.loc[sline[0]]={"sigma":float(sline[5]),"epsilon":float(sline[6])}
                                                j=j+1
                                        if sline[0] == "[" :
                                                CHOSELJ=False
                                                #print("READ END LJ")
                                #############################################

        # Calcualte the pairwise matrix of two factors using combine rule 2: sigmaij=0.5(sigma_i+sigma_j); epsilonij=sqrt(epsilon_i*epsilon_j)
        print(para.shape, paralj.shape)
        para.to_csv("atoms_pars.csv")
        paralj.to_csv("paralj.csv")
        # Matrix_eps=sqrt(np.dot(V,V.T))
        #Matrix_eps=np.dot()
        Matrix_eps=pd.DataFrame(index=paralj.index, columns=paralj.index)
        Matrix_sig=pd.DataFrame(index=paralj.index, columns=paralj.index)
        for idxr in paralj.index:
            for idxc in paralj.index:
                Matrix_eps.loc[idxr,idxc] = np.sqrt(paralj.loc[idxr]["epsilon"] * paralj.loc[idxc]["epsilon"])
                Matrix_sig.loc[idxr,idxc] = 0.5*(paralj.loc[idxr]["sigma"] + paralj.loc[idxc]["sigma"])

        print(Matrix_eps.shape)
        #, paralj["epsilon"].values)
        #print(paralj.shape, Matrix_eps.shape)
        
        return para, Matrix_eps, Matrix_sig

def Split_data(testlist,factor):
	# split data set into the number of processors
	numproc = (mp.cpu_count()-1)*factor
	numfile = len(testlist)
	setsize = int(numfile/numproc)
	resset  = numfile%numproc
	chunks  = [testlist[i:i+setsize] for i in range(0, numfile, setsize)]
	print("numproc:",numproc,"numfile:",numfile,"setsize:",setsize,"resset",resset)
	print("chunks:", len(chunks))
	return chunks

if __name__=='__main__':

	print("Help: script curves.tar.gz nucplot.tar.gz, topfile")
	print(sys.argv)
	file1=sys.argv[1]
	file2=sys.argv[2]
	file3=sys.argv[3]
	factor=5

	"""
	parser = argparse.ArgumentParser(description='Process some integers.')
	parser.add_argument('integers', metavar='N', type=int, nargs='+', 
				help='an integer for the accumulator')
	parser.add_argument('--sum', dest='accumulate', action='store_const', const=sum, default=max, 
				help='sum the integers (default: find the max)')

	args = parser.parse_args()
	print(args.accumulate(args.integers))
	"""



	Tstart=time.time()

	(atom_pars, Matrix_eps, Matrix_sig)=ATOM_PAR_LJ(file3)
	print("NUMBER OF ATOM TYPES:", len(atom_pars.index))
	print("Matrix:", Matrix_eps.shape, Matrix_sig.shape)
	#print(atom_pars)
	
	#open and load whole file in memory
	curves_byte = open(file1, "rb")
	nucplot_byte = open(file2, "rb")
	file1_like_object=io.BytesIO(curves_byte.read())
	file2_like_object=io.BytesIO(nucplot_byte.read())
	curves_byte.close()
	nucplot_byte.close()

	#load files from memory to tarfile object
	tarcurves=tarfile.open(fileobj=file1_like_object)
	tarnucplot=tarfile.open(fileobj=file2_like_object)

	curlist=[]
	for member in list(tarcurves.getmembers()):
		curlist.append(member.name)
	curlist=natsorted(curlist)
	print(len(curlist))

	nuclist=[]
	for member in list(tarnucplot.getmembers()):
		nuclist.append(member.name)
	nuclist=natsorted(nuclist)
	print(len(nuclist))

	##############################################
	"""
	
	print("RUNNING CURVES DATA")
	testlist=curlist
	# split data set into the number of processors
	chunks=Split_data(testlist, factor)

	# initialize the output files	
	curA2D=pd.DataFrame(columns=["Frame", "Level", "Xdisp", "Ydisp", "Inclin", "Tip", "Ax-bend", "Shear", "Stretch", "Stagger", "Buckle", "Propel", "Opening", "Shift", "Slide", "Rise", "Tilt", "Roll", "Twist", "H-Ris", "H-Twi", "Alpha1", "Beta1", "Gamma1", "Delta1", "Epsil1", "Zeta1", "Chi1", "Phase1", "Ampli1", "Alpha2", "Beta2", "Gamma2", "Delta2", "Epsil2", "Zeta2", "Chi2", "Phase2", "Ampli2"])
	curE=pd.DataFrame(columns=["Frame", "Level", "W12", "D12", "W21", "D21"])
	curA2D.to_csv("iCurves_dataA2D.csv")
	curE.to_csv("iCurves_dataE.csv")
	os.system("rm .iCurves_data* ")	
	#threading on
	#lock = mp.Lock()
	print("Running:")
	pool = mp.Pool(processes = mp.cpu_count()-1)
	outid=pool.map(CURVES_EXTRACT, chunks)
	pool.close()
	pool.join()
	print("Off\n", outid)
	print("process:", len(outid))
	#threading off
	
	# Merge files to sigle file
	print("Merge data:")
	for i in natsorted(list(set(outid))):
		print(i)
		os.system("cat .iCurves_dataA2D_" + str(i) + " >> iCurves_dataA2D.csv")
		os.system("cat .iCurves_dataE_" + str(i) + " >> iCurves_dataE.csv")
	os.system("rm .iCurves_data*")
	
	print("Curves finished!")
	##############################################
	#"""	

	#"""
	##############################################
	print("RUNNING NUCPLOT DATA")
	
	testlist=nuclist
	chunks=Split_data(testlist, factor*5)

	#initialize the output file
	nucdata=pd.DataFrame(columns=["Frame", "P_resname", "P_chain", "P_resid", "P_atom", "PA_charge", "D_resname", "D_chain", "D_resid", "D_atom", "DA_charge", "Dist", "Evdw", "Ecoul", "Enonb", "Type"])
	nucdata.to_csv("Nucplot_all.csv")
	os.system("rm .iNucplot_data_* ")
	#threading on
	print("Running:")
	pool = mp.Pool(processes = mp.cpu_count()-1)
	outid=pool.map(NUCPLOT_EXTRACT, chunks)
	pool.close()
	pool.join()
	print("Off\n", outid)
	print("process:", len(outid))
	#threading off 
	
	# Merge files to sigle file
	print("Merge data:")
	for x in natsorted(list(set(outid))):
		print(x)
		fname=".iNucplot_data_"+str(x)
		os.system("cat "+fname+" >> Nucplot_all.csv")
	os.system("rm .iNucplot_data_* ")
	
	print("Nucplot finished!")	
	###############################################

	#natsort dataframe index

	for f in ["iCurves_dataA2D.csv", "iCurves_dataE.csv", "Nucplot_all.csv"]:
		sdata=pd.DataFrame.from_csv(f)
		sdata=sdata.reindex(index=natsorted(sdata.index))
		sdata.to_csv(f)

	################################################
	#"""
	
	#Close memory files
	tarnucplot.close()
	tarcurves.close()

	################################################

	Tend=time.time()
	print("Total Time:", Tend - Tstart)
