# Analysis of the DNA-Protein interface from data generated by nucplot and curves program
import matplotlib
import matplotlib.pyplot as plt
from matplotlib import gridspec
from natsort import natsorted, ns
#import mdtraj as md
import multiprocessing as mp
import pandas as pd
import numpy as np
import io, os, sys, time, tarfile
import zipfile
 
class InMemoryZip(object):
 
	def __init__(self):
		# Create the in-memory file-like object
		self.in_memory_zip = io.BytesIO()
 
	def appendFile(self, file_path, file_name=None):
		if file_name is None:
			p, fn = os.path.split(file_path)
		else:
			fn = file_name
 
		c = open(file_path, "rb").read()
		self.append(fn, c)
 
		return self
 
	def append(self, filename_in_zip, file_contents):
		"""Appends a file with name filename_in_zip and contents of
			file_contents to the in-memory zip."""
 
		# Get a handle to the in-memory zip in append mode
		zf = zipfile.ZipFile(self.in_memory_zip, "a", zipfile.ZIP_DEFLATED, False)
 
		# Write the file to the in-memory zip
		zf.writestr(filename_in_zip, file_contents)
 
		# Mark the files as having been created on Windows so that
		# Unix permissions are not inferred as 0000
		for zfile in zf.filelist:
			zfile.create_system = 0
		
		return self
 
 
	def read(self):
		"""Returns a string with the contents of the in-memory zip."""
		self.in_memory_zip.seek(0)
 		
		return self.in_memory_zip.read()
 
	def writetofile(self, filename):
		"""Writes the in-memory zip to a file."""
 
		f = open(filename, "wb")
		f.write(self.read())
		f.close()
 

def NUCPLOT_EXTRACT(file_idx):
	print(file_idx)
	iidx=0
	nucdata=pd.DataFrame(columns=["Frame", "P_resname", "P_chain", "P_resid", "P_atom", "D_resname", "D_chain", "D_resid", "D_atom", "Dist", "Type"])
	frame=int(file_idx.split('.')[0].split('_')[1])
	file_name=tarnucplot.extractfile(file_idx)
	Hbond=False
	Nbond=False
	#columns=["Frame", "P_resname", "P_chain", "P_resid", "P_atom", "D_resname", "D_chain", "D_resid", "D_atom", "Dist", "Typ")
	for line in file_name.readlines():
		sline=line.decode('ASCII')
		if sline.find("HIS") >= 0:
			print("FOUND HIS IN:", file_idx)
			sline=sline.replace("HIS", "HIE")
			print(sline)
		slist=sline.split()
		slength=len(slist)
		if (Hbond == True)  and  (slength > 0) :
			if (slength == 9) and (slist[0] != 'ACE') and (slist[0]!= 'NME') and (slist[0] != 'Pt') and (slist[0]!='AME') and (slist[0]!='AMF') and (slist[4] != 'ACE') and (slist[4]!= 'NME') and (slist[4] != 'Pt') and (slist[4]!='AME') and (slist[4]!='AMF'):
				#print('HBOND:', sline)
				#extract Hbonds
				if slist[1] != "B":
					slist[0:4],slist[4:8]=slist[4:8],slist[0:4]
					#print(slist)
				nucdata.loc[str(frame)+"_"+str(iidx)]={"Frame": frame, "P_resname": slist[0], "P_chain": slist[1], "P_resid":slist[2], "P_atom":slist[3], 
						"D_resname":slist[4], "D_chain":slist[5], "D_resid":slist[6], "D_atom":slist[7], "Dist":slist[8], "Type": "HB"}
				iidx=iidx+1
			if slist[0] == "protein" :
				#print("HBOND END, NBOND START")
				Nbond=True
				Hbond=False
		else:
			#print("finding:", slength)
			if slength > 0:
				if slist[0] == "Donor" :
					#print("found Hbond")
					Hbond=True
		if (Nbond == True) and (slength > 0) :
			if (slength == 9) and (slist[0] != 'ACE') and (slist[0]!= 'NME') and (slist[0] != 'Pt') and (slist[0]!='AME') and (slist[0]!='AMF') and (slist[4] != 'ACE') and (slist[4]!= 'NME') and (slist[4] != 'Pt') and (slist[4]!='AME') and (slist[4]!='AMF'):
				#extract NBOND
				#print('NBOND:', sline)
				bt="NB"
				if float(atom_pars.loc[str(slist[0]+"_"+slist[3])]['Charge']) * float(atom_pars.loc[str(slist[4]+"_"+slist[7])]['Charge']) < -1.0e-1 :
					#print("CHARGE:",atom_pars.loc[str(slist[0]+"_"+slist[3])]['Charge'],atom_pars.loc[str(slist[4]+"_"+slist[7])]['Charge'] )
					bt="IB"
				nucdata.loc[str(frame)+"_"+str(iidx)]={"Frame": frame, "P_resname": slist[0], "P_chain": slist[1], "P_resid":slist[2], "P_atom":slist[3], 
						"D_resname":slist[4], "D_chain":slist[5], "D_resid":slist[6], "D_atom":slist[7], "Dist":slist[8], "Type": bt}
				iidx=iidx+1

			if slist[0] == "****" :
				#print("NBOND END")
				Nbond=False
				break
	#write to InMemoryZip file
	#imz.append(str(frame)+"_tmpnuc.csv", nucdata.to_csv())
	nucdata.to_csv("."+file_idx+"_tmpnuc.csv")
	return frame

def ATOM_PAR(topfile):
	para=pd.DataFrame(columns=["Charge", "Mass"])
	CHOSE=False
	IDX=0
	i=0
	with open(topfile) as lines:
		for line in lines:
			sline=line.split()
			slength=len(sline)
			if slength > 1:
				#print(i, sline)
				if (IDX < 2) and (sline[1] == "moleculetype") :
					CHOSE=True
					IDX=IDX+1
					#print("FIND SECTION")
				else:
					if (slength == 11) and (CHOSE == True) and (sline[3] != 'NME') and (sline[3] != 'ACE') and (sline[3] != 'Pt' and (sline[3] != 'AME') and (sline[3] != 'AMF')):
						para.loc[str(sline[3]+"_"+sline[4])]={"Charge": sline[6], "Mass":sline[7]}
						i=i+1
						#print("READ SECTION")
					if sline[1] == "bonds":
						CHOSE=False
						#print("READ END")
	
	return para
			
def PTM_NEW(PDB):
	atom_aly=[]
	atom_lys=[]
	atom_sep=[]
	atom_ser=[]
	with open(PDB) as lines:
		for line in lines:
			sline=line.split()
			if(sline[0]=="ATOM" and sline[3]=="ALY"):
				atom_aly.append(sline[2])
			if(sline[0]=="ATOM" and sline[3]=="LYS"):
				atom_lys.append(sline[2])
			if(sline[0]=="ATOM" and sline[3]=="SEP"):
				atom_sep.append(sline[2])
			if(sline[0]=="ATOM" and sline[3]=="SER"):
				atom_ser.append(sline[2])
	atom_aly=set(atom_aly)
	atom_lys=set(atom_lys)
	atom_sep=set(atom_sep)
	atom_ser=set(atom_ser)
	
	aly_new=(atom_lys | atom_aly) - atom_lys
	sep_new=set(atom_sep | atom_ser) - atom_ser
	#print(atom_aly)
	#print(atom_lys)
	print(aly_new, sep_new)
	return aly_new, sep_new


def Creat_Matrix(chunk):
	
	# Create a dataframe to store contactID matrix
        #NCI_contactID=pd.DataFrame(columns=ContactID)
        for frame in chunk:
                one_frame=NCI_data[NCI_data["Frame"]==frame]
                #print("Frame:", frame)
                [NCI_contactID.set_value(frame,one_frame.loc[idx]["Cname"], one_frame.loc[idx]["Dist"]) for idx in one_frame.index]
        print(NCI_contactID.shape)
        outid=os.getpid()
        NCI_contactID.to_csv(".NCI_contactID_"+str(outid), header=False)
        return outid

def Split_data(testlist):
        # split data set into the number of processors
        numproc = mp.cpu_count()-1
        numfile = len(testlist)
        setsize = int(numfile/numproc)
        resset  = numfile%numproc
        chunks  = [testlist[i:i+setsize] for i in range(0, numfile, setsize)]
        print("numproc:",numproc,"numfile:",numfile,"setsize:",setsize,"resset",resset)
        print("chunks:", len(chunks))
        return chunks

def Merge_data(outid, idfile, outfile):
	# Merge files to sigle file
	print("Merge data:")
	for i in natsorted(outid):
		print(i)
		os.system("cat "+ idfile + str(i) + " >> " + outfile)
	os.system("rm " + idfile+ "*")
	sdata=pd.DataFrame.from_csv(outfile)
	sdata=sdata.reindex(index=natsorted(sdata.index))
	sdata.to_csv(outfile)
	print(sdata.shape)
	return sdata
def map_pattern(colname, ptm, dataframe, level):
  #Attention, we must re-allocate memory for pattern DataFrame
  zeros_data=np.zeros([level+5, len(dataframe.columns)])
  pattern=pd.DataFrame(zeros_data, columns=dataframe.columns)
  for ic in range(len(pattern.columns)):
    tp = ord(list(ptm[ic])[0])
    print(tp,ptm[ic][0])
    for ir in range(level):
      if ir <= level*dataframe.loc[colname][ic]:
         pattern.set_value(pattern.index[ir], pattern.columns[ic] , tp)
    """
    if "ALY" in mty[ic]:
      pattern.set_value(pattern.index[level:level+5], pattern.columns[ic], 5)
    elif "SEP" in mty[ic]:
      pattern.set_value(pattern.index[level:level+5], pattern.columns[ic], 15)
    else:
      pattern.set_value(pattern.index[level:level+5], pattern.columns[ic], 20)
    """
  pattern.to_csv("pattern_ALLB_"+colname+".csv")
  ptnew=pattern.where(pattern>0)
  ptnew.fillna(value=100)
  fig, ax = plt.subplots()

  #pdb.set_trace()
  #cmap = mpl.cm.get_cmap('PiYG', 10)
  cax = ax.imshow(ptnew)

  #cb  = mpl.colorbar.ColorbarBase(ax2, ticks=[80,78,72,67], boundaries=[60,70,80, 90], format='%1i') 
  #ax1.set_title(colname)
#  cbar=fig.colorbar(cax, ticks=[80,78,72,67], orientation='horizontal')
#  cbar.ax.set_yticklabels(['P','N','H','C'])
  plt.savefig("pattern_ALLB_"+colname +".jpg")
  #plt.show()
  plt.close()
  return ptnew

def creat_pattern(dataframe, level):
  ptm=[]
  for ti in dataframe.columns.values:
    ptm.append(str.split(ti, "_")[3])
  for colname in ['Ratio']:
     print(colname)
     pattern=map_pattern(colname, ptm, dataframe, level)
  return 0

def CURa2d_replace(filename):
	data=pd.DataFrame.from_csv(filename)
	data=data.replace(['---','----'],['',''])
	data.to_csv(filename+".replace")
	data=pd.DataFrame.from_csv(filename+".replace")
	data=data[data.Frame> 50000]
	Std=pd.DataFrame(columns=data.columns)
	Av=pd.DataFrame(columns=data.columns)
	for level in range(1,13):
		dlevel=data[data.Level==level]
		Av.loc[level]=dlevel.mean(skipna=True, numeric_only=True)
		Std.loc[level]=dlevel.std(skipna=True)
	print(Av.shape, Std.shape)
	Av.to_csv("Curves_a2d_av.csv")
	Std.to_csv("Curves_a2d_std.csv")
		
	return Av, Std

def Creat_ContMatrix(NCI_data, outfile):

        framelist=natsorted(set(NCI_data["Frame"].values))
        chunks=Split_data(framelist)
        #threading on
        print("Running:")
        pool = mp.Pool(processes = len(chunks))
        outid=pool.map(Creat_Matrix, chunks)
        pool.close()
        pool.join()
        print("Off")
        ContactMatrix=Merge_data(outid, ".NCI_contactID_", outfile)
        print(ContactMatrix.shape)

        return ContactMatrix





if __name__=='__main__':
	print("Help: script Nucplot_classified.csv, open_in_use")
	print(sys.argv)
	nucplotAll=sys.argv[1]
	opuse=sys.argv[2]

	Tstart=time.time()

		
	
	########################
	#use only the open in range frames
	frames=list(set(pd.DataFrame.from_csv(opuse).Frame))
	print(frames[0:10])
		
	########################
	
	# load classified interactions
	NCI_data0=pd.DataFrame.from_csv("Nucplot_classified.csv")
	NCI_data0=NCI_data0.set_index(NCI_data0.Frame, drop=False)
	NCI_data1=NCI_data0.loc[frames]
	NCI_data1=NCI_data1.reset_index(drop=True)
	#print(NCI_data1)
	print(NCI_data1.shape)

	CONTACT="ALLB"

	#NCI_data=NCI_data1[NCI_data1.Type==CONTACT]
	NCI_data=NCI_data1
	print(NCI_data.shape)
	
	# Creat contacts identifier: P_resid_Presname_Patom_D_resid_Dresname_Datom_PTM
	Contacts=NCI_data["P_resid"].map(str)+"_"+NCI_data["P_resname"]+"_"+NCI_data["P_atom"]+"_"+NCI_data["PTM"]+"_"+NCI_data["D_resid"].map(str)+"_"+NCI_data["D_resname"]+"_"+NCI_data["D_atom"]
	NCI_data["Cname"]=pd.Series(Contacts, index=Contacts.index)
	ContactID=list(natsorted(set(Contacts.values)))

	# Create a dataframe to store contactID matrix
	NCI_contactID=pd.DataFrame(columns=ContactID)
	NCI_contactID.to_csv("NCI_ALLB_contactID.csv")

	# creat contact matrix
	ContactMatrix=Creat_ContMatrix(NCI_data, "NCI_ALLB_contactID.csv")
	
		
	##############################################
	# Average and std of contact distance
	ContactMatrix=pd.DataFrame.from_csv("NCI_ALLB_contactID.csv")
	

	#Dist stores statistics of distance matrix
	Dist=pd.DataFrame(columns=ContactMatrix.columns)
	Dist.loc["Average"]=ContactMatrix.mean(skipna=True, numeric_only=True)
	Dist.loc["STD"]=ContactMatrix.std(skipna=True, numeric_only=True)
	Dist.loc["Ratio"]=ContactMatrix.count(numeric_only=True)/len(ContactMatrix.index)
	cutoff=[Dist.loc["Ratio"]>0.01]
	#print(cutoff[0][0])
	Dist.loc["RatioCut01"]=cutoff[0]
	Dist.shape
	DistT=Dist.transpose()
	DistT=DistT[DistT.RatioCut01 !=0]
	Dist_cut=DistT.transpose()
	print(Dist.shape)
	Dist_cut.to_csv("NCI_ALLB_DIST_CUT.csv")
	Dist.to_csv("NCI_ALLB_DIST.csv")
		

	##############################################	
	Dist=pd.DataFrame.from_csv("NCI_ALLB_DIST.csv")
	
	fig_ratio=Dist.loc["Ratio"]
	fig_av=Dist.loc["Average"]
	fig_std=Dist.loc["STD"]
	fig, (ax0, ax1) = plt.subplots(2, sharex=True,figsize=(50,5))
	#fig = plt.figure() 
	gs = gridspec.GridSpec(2, 1, height_ratios=[1, 2]) 
	ax0 = plt.subplot(gs[0])
	ax0.plot(range(len(fig_ratio.index)), fig_ratio.values, 'r')
	ax1 = plt.subplot(gs[1],sharex=ax0)
	ax1.errorbar(range(len(fig_av.index)), fig_av.values, yerr=fig_std.values, fmt='o')
	# Fine-tune figure; make subplots close to each other and hide x ticks for
	# all but bottom plot.
	fig.subplots_adjust(hspace=0)
	plt.setp([a.get_xticklabels() for a in fig.axes[:-1]], visible=False)

	plt.savefig("Dist_ALLB_ratio.png")
	#plt.show()

	Dist_cut=pd.DataFrame.from_csv("NCI_ALLB_DIST_CUT.csv")
	creat_pattern(Dist_cut, 100)
	
		
	
	##############################################
	# Statistics of Curves data from A TO D
	#(A2D_av, A2D_std) = CURa2d_replace(curveA2D)
	
	


	##############################################
	Tend=time.time()
	print("Total Time:", Tend - Tstart)

